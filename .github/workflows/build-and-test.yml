name: Build and Test

on:
  push:
  pull_request:
  workflow_dispatch:

jobs:
  build-and-test:
    runs-on: windows-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup MSBuild
      uses: microsoft/setup-msbuild@v2
      
    - name: Setup Visual Studio Developer Command Prompt
      uses: ilammy/msvc-dev-cmd@v1
      with:
        arch: x64
    
    - name: Build icon generator
      run: |
        echo "Building icon generator..."
        cl /std:c++17 /EHsc resources\icon\create-icon.cpp /Fe:resources\icon\create-icon.exe /link gdi32.lib user32.lib
        
    - name: Generate icons
      run: |
        echo "Generating icon files..."
        cd resources\icon
        .\create-icon.exe
        cd ..\..
        
    - name: Compile resources
      run: |
        echo "Compiling resources..."
        rc /fo resources\app-resource.res resources\app-resource.rc
        
    - name: Build application
      run: |
        echo "Building ArhintSigner Web Service..."
        mkdir release -Force
        cl /std:c++17 /EHsc /O2 /W3 /I"src/include" src\arhint-signer.cpp resources\app-resource.res /Fe:release\arhint-signer.exe /link /SUBSYSTEM:WINDOWS /ENTRY:WinMainCRTStartup httpapi.lib crypt32.lib ncrypt.lib ws2_32.lib advapi32.lib shell32.lib user32.lib
        
    - name: Build test version (console mode)
      run: |
        echo "Building test version for CI..."
        cl /std:c++17 /EHsc /O2 /W3 /DCI_TEST_MODE /I"src/include" src\arhint-signer.cpp /Fe:release\arhint-signer-test.exe /link /SUBSYSTEM:CONSOLE httpapi.lib crypt32.lib ncrypt.lib ws2_32.lib advapi32.lib shell32.lib user32.lib
        
    - name: Verify build output
      run: |
        if (Test-Path "release\arhint-signer.exe") {
          echo "✅ Build successful: arhint-signer.exe created"
          $fileInfo = Get-Item "release\arhint-signer.exe"
          echo "File size: $($fileInfo.Length) bytes"
          echo "Created: $($fileInfo.CreationTime)"
        } else {
          echo "❌ Build failed: arhint-signer.exe not found"
          exit 1
        }
        
    - name: Reserve HTTP URL
      run: |
        echo "Reserving HTTP URL..."
        # Delete existing reservation if present
        netsh http delete urlacl url=http://+:8082/ 2>$null
        # Add new reservation for the current user and NETWORK SERVICE
        netsh http add urlacl url=http://+:8082/ user=Everyone
        echo "✅ HTTP URL reserved successfully"
        
    - name: Start web service and run tests
      run: |
        echo "Starting ArhintSigner web service (test mode)..."
        
        # Start the service in background
        $psi = New-Object System.Diagnostics.ProcessStartInfo
        $psi.FileName = (Resolve-Path "release\arhint-signer-test.exe").Path
        $psi.Arguments = "8082"
        $psi.UseShellExecute = $false
        $psi.CreateNoWindow = $true
        
        $process = [System.Diagnostics.Process]::Start($psi)
        echo "✅ Service started with PID: $($process.Id)"
        
        try {
          # Wait for service to be ready
          echo "Waiting for service to initialize..."
          $maxAttempts = 15
          $attempt = 0
          $serviceReady = $false
          
          while ($attempt -lt $maxAttempts -and -not $serviceReady) {
            Start-Sleep -Seconds 1
            $attempt++
            
            # Check if process is still running
            if ($process.HasExited) {
              echo "❌ Service process exited with code: $($process.ExitCode)"
              exit 1
            }
            
            try {
              $response = Invoke-WebRequest -Uri "http://localhost:8082/" -Method GET -UseBasicParsing -TimeoutSec 2 -ErrorAction Stop
              if ($response.StatusCode -eq 200) {
                $serviceReady = $true
                echo "✅ Service is ready after $attempt seconds"
              }
            } catch {
              if ($attempt % 5 -eq 0) {
                echo "Attempt $attempt/$maxAttempts..."
              }
            }
          }
          
          if (-not $serviceReady) {
            echo "❌ Service failed to respond within $maxAttempts seconds"
            exit 1
          }
          
          # Test 1: Health endpoint (root page)
          echo ""
          echo "=== Testing root endpoint (health check) ==="
          $response = Invoke-WebRequest -Uri "http://localhost:8082/" -Method GET -UseBasicParsing
          echo "Status Code: $($response.StatusCode)"
          echo "Content-Type: $($response.Headers['Content-Type'])"
          
          if ($response.StatusCode -eq 200) {
            echo "✅ Health check passed (root page returned)"
          } else {
            echo "❌ Health check failed"
            exit 1
          }
          
          # Test 2: ListCerts endpoint
          echo ""
          echo "=== Testing listCerts endpoint ==="
          $response = Invoke-WebRequest -Uri "http://localhost:8082/listCerts" -Method GET -UseBasicParsing
          echo "Status Code: $($response.StatusCode)"
          echo "Response: $($response.Content)"
          $json = $response.Content | ConvertFrom-Json
          
          if ($response.StatusCode -eq 200 -and $null -ne $json.result) {
            echo "✅ ListCerts endpoint working"
            echo "Found $($json.result.Count) certificates"
          } else {
            echo "❌ ListCerts endpoint failed"
            echo "Response was: $($response.Content)"
            exit 1
          }
          
          # Test 3: Sign endpoint with invalid data
          echo ""
          echo "=== Testing sign endpoint (should reject invalid input) ==="
          $headers = @{ "Content-Type" = "application/json" }
          $body = @{ hash = ""; thumbprint = "" } | ConvertTo-Json
          
          try {
            $response = Invoke-WebRequest -Uri "http://localhost:8082/sign" -Method POST -Headers $headers -Body $body -UseBasicParsing
            echo "❌ Sign endpoint should have rejected empty input"
            exit 1
          } catch {
            $statusCode = $_.Exception.Response.StatusCode.value__
            if ($statusCode -eq 400) {
              echo "✅ Sign endpoint correctly rejected invalid input (400)"
            } else {
              echo "❌ Unexpected status code: $statusCode"
              exit 1
            }
          }
          
          # Test 4: Sign endpoint with test certificate
          echo ""
          echo "=== Testing sign endpoint with test certificate ==="
          
          # Create a self-signed test certificate
          $cert = New-SelfSignedCertificate -Subject "CN=Test Signing Certificate" -CertStoreLocation "Cert:\CurrentUser\My" -KeyUsage DigitalSignature -KeySpec Signature -KeyLength 2048
          $thumbprint = $cert.Thumbprint
          echo "Created test certificate with thumbprint: $thumbprint"
          
          # Create a test hash (base64 encoded SHA256 hash)
          $testData = [System.Text.Encoding]::UTF8.GetBytes("Test data to sign")
          $sha256 = [System.Security.Cryptography.SHA256]::Create()
          $hashBytes = $sha256.ComputeHash($testData)
          $hashBase64 = [Convert]::ToBase64String($hashBytes)
          echo "Test hash (base64): $hashBase64"
          
          # Test signing
          $signBody = @{
            hash = $hashBase64
            thumbprint = $thumbprint
          } | ConvertTo-Json
          
          try {
            $signResponse = Invoke-WebRequest -Uri "http://localhost:8082/sign" -Method POST -Headers $headers -Body $signBody -UseBasicParsing
            $signJson = $signResponse.Content | ConvertFrom-Json
            
            if ($signResponse.StatusCode -eq 200 -and $signJson.result) {
              echo "✅ Sign endpoint working - received signature"
              echo "Signature length: $($signJson.result.Length) characters"
              
              # Validate the signature
              echo "Validating signature..."
              $signatureBase64 = $signJson.result
              $signatureBytes = [Convert]::FromBase64String($signatureBase64)
              
              # Get the public key from the certificate
              $publicKey = $cert.PublicKey.Key
              
              # Verify the signature
              $isValid = $publicKey.VerifyHash($hashBytes, [System.Security.Cryptography.CryptoConfig]::MapNameToOID("SHA256"), $signatureBytes)
              
              if ($isValid) {
                echo "✅ Signature validation passed - signature is cryptographically valid"
              } else {
                echo "❌ Signature validation failed - signature is invalid"
                exit 1
              }
            } else {
              echo "❌ Sign endpoint failed"
              echo "Response: $($signResponse.Content)"
              exit 1
            }
          } catch {
            echo "❌ Sign endpoint test failed: $_"
            if ($_.Exception.Response) {
              $reader = New-Object System.IO.StreamReader($_.Exception.Response.GetResponseStream())
              $responseBody = $reader.ReadToEnd()
              echo "Error response: $responseBody"
            }
            exit 1
          } finally {
            # Clean up test certificate
            Remove-Item "Cert:\CurrentUser\My\$thumbprint" -ErrorAction SilentlyContinue
            echo "Test certificate removed"
          }
          
          # Test 5: CORS headers
          echo ""
          echo "=== Testing CORS headers ==="
          $response = Invoke-WebRequest -Uri "http://localhost:8082/" -Method GET -UseBasicParsing
          $corsHeader = $response.Headers["Access-Control-Allow-Origin"]
          
          if ($corsHeader -eq "*") {
            echo "✅ CORS headers present and correct"
          } else {
            echo "⚠️ CORS header: $corsHeader"
          }
          
          echo ""
          echo "✅ All tests passed!"
          
        } finally {
          # Always stop the service
          echo ""
          echo "Stopping web service..."
          if (-not $process.HasExited) {
            $process.Kill()
            $process.WaitForExit(5000)
            echo "✅ Service stopped"
          }
        }
        
    - name: Upload build artifacts
      if: success()
      uses: actions/upload-artifact@v4
      with:
        name: arhint-signer-build
        path: |
          release/arhint-signer.exe
          examples/example-arhint-signer.html
        retention-days: 30
        
    - name: Test cleanup
      if: always()
      run: |
        echo "Cleaning up test resources..."
        # Kill any remaining processes
        Get-Process | Where-Object { $_.ProcessName -eq "arhint-signer" } | Stop-Process -Force -ErrorAction SilentlyContinue
        echo "✅ Cleanup complete"
